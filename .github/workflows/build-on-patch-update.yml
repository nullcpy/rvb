name: Build on Patch Update

on:
  schedule:
    - cron: "20 */4 * * *" # Every 4 hours
  workflow_dispatch:

concurrency:
  group: patch-build
  cancel-in-progress: false

env:
  TG_CHAT: "@rvb27"
  TG_CHANNEL: "@rvb28"

jobs:
  check-patch:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    outputs:
      trigger_stable: ${{ steps.compare.outputs.TRIGGER_STABLE }}
      trigger_prerelease: ${{ steps.compare.outputs.TRIGGER_PRERELEASE }}
      tags_old: ${{ steps.compare.outputs.tags_old }}
      tags_new: ${{ steps.compare.outputs.tags_new }}
      stable_config: ${{ steps.generate_configs.outputs.stable_config }}
      dev_config: ${{ steps.generate_configs.outputs.dev_config }}
      next_stable_ver: ${{ steps.versions.outputs.next_stable_ver }}
      next_dev_ver: ${{ steps.versions.outputs.next_dev_ver }}
    steps:
      - name: Checkout (Main)
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          submodules: true

      - name: Create .github/misc directory
        run: mkdir -p .github/misc

      - name: Ensure patch_sources.json exists
        id: ensure_patch_sources
        run: |
          set -euo pipefail
          PATCH_FILE=".github/misc/patch_sources.json"

          if [ ! -f "$PATCH_FILE" ]; then
            cat > "$PATCH_FILE" << 'EOF'
          {
            "patch": { "repo": "", "stable": "", "prerelease": "" }
          }
          EOF
            echo "created=true" >> "$GITHUB_OUTPUT"
          else
            echo "created=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit dummy patch_sources.json if created
        if: steps.ensure_patch_sources.outputs.created == 'true'
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          skip_checkout: true
          file_pattern: .github/misc/patch_sources.json
          commit_message: "Create dummy patch_sources.json"

      # Only continue if patch_sources.json already existed (not just created)
      - name: Fetch Latest Tags (from patch_sources.json)
        if: steps.ensure_patch_sources.outputs.created == 'false'
        id: fetch_tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PATCH_FILE=".github/misc/patch_sources.json"

          BASE_JSON=$(cat "$PATCH_FILE")
          # If empty JSON (no entries), just propagate as-is
          if echo "$BASE_JSON" | jq -e 'length == 0' >/dev/null; then
            DELIM="$(openssl rand -hex 8)"
            echo "latest<<${DELIM}" >> "$GITHUB_OUTPUT"
            echo "$BASE_JSON" >> "$GITHUB_OUTPUT"
            echo "${DELIM}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          get_latest_tag() {
            local repo=$1
            local prerelease=$2

            # Fetch releases with auth, grab body + status
            local resp status body
            resp=$(curl -sS -w '%{http_code}' \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$repo/releases" || true)

            status="${resp: -3}"
            body="${resp::-3}"

            # On non-200, treat as "no tag"
            if [ "$status" != "200" ]; then
              echo ""
              return 0
            fi

            printf '%s\n' "$body" | jq -r "
              map(select(.prerelease == $prerelease and .tag_name != null and .tag_name != \"\")) |
              sort_by(.published_at) |
              reverse |
              .[0].tag_name // \"\"
            "
          }

          NEW_JSON="$BASE_JSON"

          # For each patch source, get stable + prerelease tags (skip empty repo)
          while read -r id repo; do
            stable=$(get_latest_tag "$repo" false)
            pre=$(get_latest_tag "$repo" true)

            NEW_JSON=$(jq \
              --arg id "$id" \
              --arg stable "$stable" \
              --arg pre "$pre" \
              '.[$id].stable = $stable | .[$id].prerelease = $pre' \
              <<<"$NEW_JSON")
          done < <(echo "$BASE_JSON" | jq -r 'to_entries[] | select(.value.repo != "") | "\(.key) \(.value.repo)"')

          DELIM="$(openssl rand -hex 8)"
          echo "latest<<${DELIM}" >> "$GITHUB_OUTPUT"
          echo "$NEW_JSON" >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"

      - name: Compare Latest vs Stored Tags
        if: steps.ensure_patch_sources.outputs.created == 'false'
        id: compare
        run: |
          set -euo pipefail

          PATCH_FILE=".github/misc/patch_sources.json"

          OLD_JSON=$(cat "$PATCH_FILE")
          NEW_JSON='${{ steps.fetch_tags.outputs.latest }}'

          # Safety: if NEW_JSON is empty for some reason, treat as empty JSON
          if [ -z "$NEW_JSON" ]; then
            NEW_JSON="{}"
          fi

          # Compute triggers
          TRIGGER_STABLE=$(jq -n --argjson old "$OLD_JSON" --argjson new "$NEW_JSON" '
            [ $new | to_entries[] | . as $e
              | ($old[$e.key] // {}) as $o
              | select($e.value.stable != "" and $e.value.stable != ($o.stable // ""))
            ] | if length > 0 then 1 else 0 end
          ')

          TRIGGER_PRERELEASE=$(jq -n --argjson old "$OLD_JSON" --argjson new "$NEW_JSON" '
            [ $new | to_entries[] | . as $e
              | ($old[$e.key] // {}) as $o
              | select($e.value.prerelease != "" and $e.value.prerelease != ($o.prerelease // ""))
            ] | if length > 0 then 1 else 0 end
          ')

          # Update patch_sources.json to the new tags
          echo "$NEW_JSON" > "$PATCH_FILE"

          echo "TRIGGER_STABLE=$TRIGGER_STABLE" >> "$GITHUB_OUTPUT"
          echo "TRIGGER_PRERELEASE=$TRIGGER_PRERELEASE" >> "$GITHUB_OUTPUT"

          # Expose old & new JSON as outputs
          DELIM1="$(openssl rand -hex 8)"
          echo "tags_old<<${DELIM1}" >> "$GITHUB_OUTPUT"
          echo "$OLD_JSON" >> "$GITHUB_OUTPUT"
          echo "${DELIM1}" >> "$GITHUB_OUTPUT"

          DELIM2="$(openssl rand -hex 8)"
          echo "tags_new<<${DELIM2}" >> "$GITHUB_OUTPUT"
          echo "$NEW_JSON" >> "$GITHUB_OUTPUT"
          echo "${DELIM2}" >> "$GITHUB_OUTPUT"

      - name: Commit Updated patch_sources.json
        if: steps.ensure_patch_sources.outputs.created == 'false' && (steps.compare.outputs.TRIGGER_STABLE == '1' || steps.compare.outputs.TRIGGER_PRERELEASE == '1')
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          skip_checkout: true
          file_pattern: .github/misc/patch_sources.json
          commit_message: "Update patch_sources.json with latest patch versions"

      - name: Generate Configs (Stable and Dev)
        if: steps.ensure_patch_sources.outputs.created == 'false' && (steps.compare.outputs.TRIGGER_STABLE == '1' || steps.compare.outputs.TRIGGER_PRERELEASE == '1')
        id: generate_configs
        env:
          TAGS_OLD: ${{ steps.compare.outputs.tags_old }}
          TAGS_NEW: ${{ steps.compare.outputs.tags_new }}
        run: |
          set -euo pipefail

          BASE_CONFIG="config.toml"

          # Build ACTIVE repo lists:
          # For STABLE: repos where new.stable is non-empty AND changed vs old
          # For PRERELEASE: repos where new.prerelease is non-empty AND changed vs old

          # active.stable.txt
          jq -rn --argjson new "$TAGS_NEW" --argjson old "$TAGS_OLD" '
            [ $new | to_entries[] | . as $e
                | ($old[$e.key] // {}) as $o
                | select($e.value.stable != "" and $e.value.stable != ($o.stable // ""))
                | $e.value.repo
            ] | .[]
          ' > .github/misc/active.stable.txt || true

          # active.prerelease.txt
          jq -rn --argjson new "$TAGS_NEW" --argjson old "$TAGS_OLD" '
            [ $new | to_entries[] | . as $e
                | ($old[$e.key] // {}) as $o
                | select($e.value.prerelease != "" and $e.value.prerelease != ($o.prerelease // ""))
                | $e.value.repo
            ] | .[]
          ' > .github/misc/active.prerelease.txt || true

          generate_config() {
            local mode="$1" # stable | dev
            local out_file=".github/misc/config.$mode.updated.toml"
            cp "$BASE_CONFIG" "$out_file"

            # Inject mode-specific global settings BEFORE patch toggling:
            if [ "$mode" = "stable" ]; then
              # Stable: magisk update enabled
              {
                echo 'enable-magisk-update = true'
                cat "$out_file"
              } > tmp_header
              mv tmp_header "$out_file"
            else
              # Dev: patches-version + magisk update disabled
              {
                echo 'patches-version = "dev"'
                echo 'cli-version = "dev"'
                echo 'enable-magisk-update = false'
                cat "$out_file"
              } > tmp_header
              mv tmp_header "$out_file"
            fi

            local active_file
            if [ "$mode" = "stable" ]; then
              active_file=".github/misc/active.stable.txt"
            else
              active_file=".github/misc/active.prerelease.txt"
            fi

            # Ensure active file exists (may be empty)
            touch "$active_file"

            awk -v active_file="$active_file" '
              BEGIN {
                # Load active repos into associative array
                while ((getline repo < active_file) > 0) {
                  if (repo != "") active[repo] = 1
                }
                close(active_file)
                section = ""
                keep = 0
              }
              /^\[.*\]/ {
                flush_section()
                section = $0
                delete lines
                n = 0
                lines[n++] = $0
                keep = 0   # default: disable section unless it matches an active repo
                next
              }
              {
                lines[n++] = $0
                if ($0 ~ /patches-source *= *"[^"]+"/) {
                  match($0, /patches-source *= *"([^"]+)"/, m)
                  src = m[1]
                  if (src in active) {
                    keep = 1
                  }
                }
                next
              }
              END {
                flush_section()
              }
              function flush_section() {
                if (n == 0) return
                for (i = 0; i < n; i++) {
                  line = lines[i]
                  if (!keep) {
                    gsub(/enabled *= *true/, "enabled = false", line)
                  }
                  print line
                }
              }
            ' "$out_file" > tmp && mv tmp "$out_file"

            echo "${mode}_config=${out_file}" >> "$GITHUB_OUTPUT"
          }

          if [ "${{ steps.compare.outputs.TRIGGER_STABLE }}" = "1" ]; then
            generate_config "stable"
          fi

          if [ "${{ steps.compare.outputs.TRIGGER_PRERELEASE }}" = "1" ]; then
            generate_config "dev"
          fi

      - name: Commit Updated Config (Stable)
        if: steps.ensure_patch_sources.outputs.created == 'false' && steps.compare.outputs.TRIGGER_STABLE == '1'
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          file_pattern: .github/misc/config.stable.updated.toml
          commit_message: "Update config.stable.updated.toml for new stable patches"

      - name: Commit Updated Config (Dev)
        if: steps.ensure_patch_sources.outputs.created == 'false' && steps.compare.outputs.TRIGGER_PRERELEASE == '1'
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          file_pattern: .github/misc/config.dev.updated.toml
          commit_message: "Update config.dev.updated.toml for new dev patches"

      - name: Generate Version Numbers (Stable and Dev)
        if: steps.ensure_patch_sources.outputs.created == 'false' && (steps.compare.outputs.TRIGGER_STABLE == '1' || steps.compare.outputs.TRIGGER_PRERELEASE == '1')
        id: versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TAG=$(gh release list --exclude-drafts -L 100 | awk -F '\t' '{print $3}' | grep -E '^[0-9]+$' | sort -nr | head -n1)
          if [ -z "$TAG" ] || ! [[ "$TAG" =~ ^[0-9]+$ ]]; then TAG=0; fi

          TRIGGER_STABLE=${{ steps.compare.outputs.TRIGGER_STABLE }}
          TRIGGER_PRERELEASE=${{ steps.compare.outputs.TRIGGER_PRERELEASE }}

          NEXT_STABLE=""
          NEXT_DEV=""

          if [ "$TRIGGER_STABLE" = "1" ] && [ "$TRIGGER_PRERELEASE" = "1" ]; then
            NEXT_STABLE=$((TAG + 2))
            NEXT_DEV=$((TAG + 1))
          elif [ "$TRIGGER_STABLE" = "1" ]; then
            NEXT_STABLE=$((TAG + 1))
          elif [ "$TRIGGER_PRERELEASE" = "1" ]; then
            NEXT_DEV=$((TAG + 1))
          fi

          echo "next_stable_ver=${NEXT_STABLE}" >> "$GITHUB_OUTPUT"
          echo "next_dev_ver=${NEXT_DEV}" >> "$GITHUB_OUTPUT"

  build-dev:
    needs: check-patch
    if: needs.check-patch.outputs.trigger_prerelease == '1'
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (Main)
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          submodules: true

      - name: Setup Java (Zulu 17)
        uses: actions/setup-java@v5
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Notify Telegram (New Dev Patch)
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_THREAD_ID: "345"
          TAGS_OLD: ${{ needs.check-patch.outputs.tags_old }}
          TAGS_NEW: ${{ needs.check-patch.outputs.tags_new }}
        run: |
          set -euo pipefail
          NL=$'\n'
          MSG="*New Patch Detected!* (Pre-release)${NL}"

          CHANGES=$(jq -n --argjson old "$TAGS_OLD" --argjson new "$TAGS_NEW" '
            [ $new | to_entries[] | . as $e
              | ($old[$e.key] // {}) as $o
              | select($e.value.prerelease != "" and $e.value.prerelease != ($o.prerelease // ""))
              | {
                  key: $e.key,
                  repo: $e.value.repo,
                  old: ($o.prerelease // ""),
                  new: $e.value.prerelease
                }
            ]
          ')

          if [ "$(echo "$CHANGES" | jq 'length')" -eq 0 ]; then
            MSG+="${NL}(Patch versions changed, but details could not be parsed)${NL}"
          else
            while read -r item; do
              name=$(echo "$item" | jq -r '.key')
              repo=$(echo "$item" | jq -r '.repo')
              old=$(echo "$item" | jq -r '.old')
              new=$(echo "$item" | jq -r '.new')
              MSG+="${NL}â€¢ [${name}](https://github.com/${repo}/releases/tag/${new}):${NL}Old: \`${old}\` â†’ New: \`${new}\`${NL}"
            done < <(echo "$CHANGES" | jq -c '.[]')
          fi

          MSG+="${NL}[Triggering new build...](https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)"
          MSG=${MSG:0:9450}

          curl -X POST \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "chat_id=${TG_CHAT}" \
            --data-urlencode "message_thread_id=${TG_THREAD_ID}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

      - name: Build Modules and APKs (Dev)
        run: |
          set -euo pipefail
          rm -rf build
          mkdir -p build
          ./build.sh .github/misc/config.dev.updated.toml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: $GITHUB_REPOSITORY
          NEXT_VER_CODE: ${{ needs.check-patch.outputs.next_dev_ver }}

      - name: Get Output (Dev)
        id: get_output_dev
        run: |
          set -euo pipefail
          DELIM="$(openssl rand -hex 8)"
          echo "BUILD_LOG<<${DELIM}" >> "$GITHUB_OUTPUT"
          cat build.md >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"
          cp -f build.md build.tmp

      - name: Upload to Release (Dev)
        uses: svenstaro/upload-release-action@v2
        with:
          body: ${{ steps.get_output_dev.outputs.BUILD_LOG }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ./build/*
          file_glob: true
          release_name: Build No. ${{ needs.check-patch.outputs.next_dev_ver }}
          tag: ${{ needs.check-patch.outputs.next_dev_ver }}
          prerelease: true
          overwrite: true

      - name: Upload to BuzzHeavier (Dev)
        id: upload_buzzheavier_dev
        env:
          BUZZHEAVIER_ACCOUNT_ID: ${{ secrets.BUZZHEAVIER_ACCOUNT_ID }}
          RELEASE_NUMBER: ${{ needs.check-patch.outputs.next_dev_ver }}
        run: |
          set -euo pipefail
          cd build || { echo "build folder not found"; exit 1; }

          # Create full archive ONCE
          ARCHIVE_NAME="archive-$RELEASE_NUMBER.zip"
          echo "ðŸ“¦ Creating full archive: $ARCHIVE_NAME"
          zip -q9 "$ARCHIVE_NAME" *

          TOKEN=$(echo "$BUZZHEAVIER_ACCOUNT_ID" | xargs)
          if [ -z "$TOKEN" ]; then
            echo "âŒ BUZZHEAVIER_ACCOUNT_ID secret is missing"
            exit 1
          fi
          AUTH="Authorization: Bearer $TOKEN"
          PARENT_ID="qapeaw1yzy6m"

          echo "âœ… Using revanced-builder directory ID: $PARENT_ID"
          echo "ðŸ” Checking if folder '$RELEASE_NUMBER' already exists..."

          # Fetch parent contents
          PARENT_CONTENTS=$(curl -sS -H "$AUTH" "https://buzzheavier.com/api/fs/$PARENT_ID")
          EXISTING_ID=$(echo "$PARENT_CONTENTS" | jq -r ".data.children[] // [] | select(.name == \"$RELEASE_NUMBER\" and .isDirectory == true) | .id // empty")

          if [ -n "$EXISTING_ID" ]; then
            echo "ðŸ—‘ï¸ Deleting existing folder '$RELEASE_NUMBER' (ID: $EXISTING_ID)..."
            curl -sS -X DELETE -H "$AUTH" "https://buzzheavier.com/api/fs/$EXISTING_ID" || true
            sleep 1
          fi

          echo "ðŸ“ Creating fresh folder: $RELEASE_NUMBER"
          CREATE_RES=$(curl -sS -X POST \
            -H "$AUTH" \
            -H "Content-Type: application/json" \
            -d "{\"name\":\"$RELEASE_NUMBER\"}" \
            "https://buzzheavier.com/api/fs/$PARENT_ID")

          RELEASE_DIR_ID=$(echo "$CREATE_RES" | jq -r '.data.id // empty')
          if [ -z "$RELEASE_DIR_ID" ]; then
            echo "âŒ Failed to create folder. Response: $CREATE_RES"
            exit 1
          fi
          echo "âœ… Folder created with ID: $RELEASE_DIR_ID"

          # Upload ALL files
          SUCCESS_COUNT=0
          for FILE in *; do
            if [ -f "$FILE" ]; then
              echo "â¬†ï¸ Uploading $FILE..."
              if curl -# -T "$FILE" -H "$AUTH" "https://w.buzzheavier.com/$RELEASE_DIR_ID/$FILE"; then
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                echo "âš ï¸ Failed to upload $FILE"
              fi
            fi
          done

          if [ "$SUCCESS_COUNT" -gt 0 ]; then
            PUBLIC_LINK="https://buzzheavier.com/$RELEASE_DIR_ID"
            echo "BUZZHEAVIER_LINK=$PUBLIC_LINK" >> "$GITHUB_OUTPUT"
            echo "UPLOAD_SUCCESS=true" >> "$GITHUB_OUTPUT"
            echo "âœ… Uploaded $SUCCESS_COUNT files. Mirror: $PUBLIC_LINK"
          else
            echo "UPLOAD_SUCCESS=false" >> "$GITHUB_OUTPUT"
            echo "BUZZHEAVIER_LINK=" >> "$GITHUB_OUTPUT"
            echo "âŒ No files uploaded to BuzzHeavier."
          fi

          echo "ðŸ§¹ Scanning for stale empty folders..."
          CLEANUP_CONTENTS=$(curl -sS -H "$AUTH" "https://buzzheavier.com/api/fs/$PARENT_ID")
          
          CANDIDATE_IDS=$(echo "$CLEANUP_CONTENTS" | jq -r ".data.children[] // [] | select(.isDirectory == true and .id != \"$RELEASE_DIR_ID\") | .id")

          for CID in $CANDIDATE_IDS; do
            CHILD_INFO=$(curl -sS -H "$AUTH" "https://buzzheavier.com/api/fs/$CID")
            
            ITEM_COUNT=$(echo "$CHILD_INFO" | jq '.data.children // [] | length')

            if [ "$ITEM_COUNT" -eq "0" ]; then
               echo "ðŸ—‘ï¸ Folder ID $CID is EMPTY (stale). Deleting..."
               curl -sS -X DELETE -H "$AUTH" "https://buzzheavier.com/api/fs/$CID" || true
            fi
          done

      - name: Upload to Filebin (Dev)
        id: upload_filebin_dev
        run: |
          set -euo pipefail
          cd build || { echo "build folder not found"; exit 1; }

          RELEASE_NUMBER="${{ needs.check-patch.outputs.next_dev_ver }}"
          ARCHIVE_NAME="archive-$RELEASE_NUMBER.zip"

          # The archive was created in BuzzHeavier step
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "âŒ Expected archive $ARCHIVE_NAME not found!"
            exit 1
          fi

          BIN_ID="revanced-builder-dev-${RELEASE_NUMBER}-${{ github.run_id }}-${{ github.run_attempt }}"
          FILEBIN_URL="https://filebin.net"

          echo "â¬†ï¸ Uploading $ARCHIVE_NAME to Filebin bin: $BIN_ID"
          if curl --connect-timeout 30 --max-time 300 --fail-with-body --upload-file "$ARCHIVE_NAME" "$FILEBIN_URL/$BIN_ID/$ARCHIVE_NAME"; then
            echo "âœ… $ARCHIVE_NAME uploaded to Filebin"
            # Lock bin
            if curl --connect-timeout 10 --max-time 30 --fail-with-body -X PUT "$FILEBIN_URL/$BIN_ID"; then
              echo "ðŸ”’ Bin locked successfully."
            else
              echo "âš ï¸ Failed to lock bin (not critical)."
            fi
            echo "UPLOAD_SUCCESS=true" >> "$GITHUB_OUTPUT"
            echo "FILEBIN_LINK=$FILEBIN_URL/$BIN_ID/$ARCHIVE_NAME" >> "$GITHUB_OUTPUT"
          else
            echo "âŒ Failed to upload $ARCHIVE_NAME to Filebin."
            echo "UPLOAD_SUCCESS=false" >> "$GITHUB_OUTPUT"
            echo "FILEBIN_LINK=" >> "$GITHUB_OUTPUT"
          fi

          # DELETE archive-$RELEASE_NUMBER.zip AFTER upload (so it doesn't appear in Telegram)
          if [ -f "$ARCHIVE_NAME" ]; then
            echo "ðŸ—‘ï¸ Removing $ARCHIVE_NAME from local build dir"
            rm -f "$ARCHIVE_NAME"
          fi

      - name: Update Mirror Links (Dev)
        id: update_mirrors_dev
        env:
          RELEASE_NUM: ${{ needs.check-patch.outputs.next_dev_ver }}
          RELEASE_TYPE: "Pre-release"
          BUZZ_LINK: ${{ steps.upload_buzzheavier_dev.outputs.BUZZHEAVIER_LINK }}
          FILEBIN_LINK: ${{ steps.upload_filebin_dev.outputs.FILEBIN_LINK }}
        run: |
          set -euo pipefail

          # Ensure directory and file exist
          MIRRORS_DIR=".github/pages"
          MIRRORS_FILE="$MIRRORS_DIR/mirrors.md"
          mkdir -p "$MIRRORS_DIR"

          if [ ! -f "$MIRRORS_FILE" ]; then
            echo "# ðŸ—ƒï¸ Mirrors" > "$MIRRORS_FILE"
            echo "Updated automatically. Only recent 100 builds retained." >> "$MIRRORS_FILE"
            echo "" >> "$MIRRORS_FILE"
          fi

          # Skip if no release number (shouldn't happen, but safe)
          if [ -z "$RELEASE_NUM" ]; then
            echo "âš ï¸ No release number â€” skipping mirror update"
            exit 0
          fi

          # Create entry
          ENTRY="## Build No. $RELEASE_NUM ($RELEASE_TYPE)  \n"
          if [ -n "$BUZZ_LINK" ]; then
            ENTRY+="ðŸ”— [BuzzHeavier]($BUZZ_LINK)  \n"
          fi
          if [ -n "$FILEBIN_LINK" ]; then
            ENTRY+="ðŸ”— [Filebin]($FILEBIN_LINK)  \n"
          fi
          if [ -z "$BUZZ_LINK" ] && [ -z "$FILEBIN_LINK" ]; then
            ENTRY+="âš ï¸ No mirrors available. Check [GitHub Release](https://github.com/$GITHUB_REPOSITORY/releases/tag/$RELEASE_NUM).  \n"
          fi
          ENTRY+="\n"

          # Create new file with: header + new entry + old entries (limited to 99 to keep 100 total)
          {
            # Keep header (first 3 lines)
            head -n 3 "$MIRRORS_FILE"
            # Add new entry
            echo -e "$ENTRY"
            # Add old entries (skip first 3 lines), keep only 99 blocks
            tail -n +4 "$MIRRORS_FILE" | awk '/^## Build No\./ { 
              if (block_count >= 99) { exit }
              block_count++
            }
            block_count <= 99 { print }'
          } > "$MIRRORS_FILE.tmp" && mv "$MIRRORS_FILE.tmp" "$MIRRORS_FILE"

      - name: Commit Updated mirrors.md (Dev)
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          skip_checkout: true
          file_pattern: .github/pages/mirrors.md
          commit_message: "Update mirrors.md for Build No. ${{ needs.check-patch.outputs.next_dev_ver }}"

      - name: Update Changelog and Magisk Update JSON (Dev)
        run: |
          set -euo pipefail
          git checkout -f update || git switch --discard-changes --orphan update
          cp -f build.tmp build.md
          get_update_json() {
            echo "{
            \"version\": \"$1\",
            \"versionCode\": ${{ needs.check-patch.outputs.next_dev_ver }},
            \"zipUrl\": \"$2\",
            \"changelog\": \"https://raw.githubusercontent.com/$GITHUB_REPOSITORY/update/build.md\"
          }"
          }
          cd build || { echo "build folder not found"; exit 1; }
          for OUTPUT in *magisk*.zip; do
            [ "$OUTPUT" = "*magisk*.zip" ] && continue
            ZIP_S=$(unzip -p "$OUTPUT" module.prop)
            if ! UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson); then continue; fi
            UPDATE_JSON="${UPDATE_JSON##*/}"
            VER=$(echo "$ZIP_S" | grep version=)
            VER="${VER##*=}"
            DLURL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ needs.check-patch.outputs.next_dev_ver }}/${OUTPUT}"
            get_update_json "$VER" "$DLURL" >"../$UPDATE_JSON"
          done
          cd ..
          find . -name "*-update.json" | grep . || : >dummy-update.json

      - name: Commit Updated Build MD and Update JSON Files (Dev)
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: update
          skip_checkout: true
          file_pattern: build.md *-update.json
          commit_message: Bump version ${{ needs.check-patch.outputs.next_dev_ver }}

      - name: Notify Telegram (Dev Build Complete)
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_THREAD_ID: "350"
          FILEBIN_LINK: ${{ steps.upload_filebin_dev.outputs.FILEBIN_LINK }}
          FILEBIN_SUCCESS: ${{ steps.upload_filebin_dev.outputs.UPLOAD_SUCCESS }}
          BUZZHEAVIER_LINK: ${{ steps.upload_buzzheavier_dev.outputs.BUZZHEAVIER_LINK }}
          BUZZHEAVIER_SUCCESS: ${{ steps.upload_buzzheavier_dev.outputs.UPLOAD_SUCCESS }}
        run: |
          set -euo pipefail
          cd build || exit 1
          NL=$'\n'
          APKS=""
          MODULES=""
          HAS_MODULES=false

          for OUTPUT in *; do
            DL_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ needs.check-patch.outputs.next_dev_ver }}/${OUTPUT}"
            if [[ $OUTPUT = *.apk ]]; then
              APKS+="${NL}${NL}[${OUTPUT}](${DL_URL})"
            elif [[ $OUTPUT = *.zip ]]; then
              MODULES+="${NL}${NL}[${OUTPUT}](${DL_URL})"
              HAS_MODULES=true
            fi
          done

          MODULES=${MODULES#"$NL"}
          APKS=${APKS#"$NL"}

          BODY="$(sed 's/^\* \*\*/â†ª \*\*/g; s/^\* `/â†ª \*\*/g; s/`/\*/g; s/^\* /\â†ª/g; s/\*\*/\*/g; s/###//g; s/^- /â†ª /g; /^==/d;' ../build.md)"

          MSG="*Build No. ${{ needs.check-patch.outputs.next_dev_ver }}* (Pre-release)${NL}${NL}${BODY}${NL}${NL}"

          MIRRORS=""
          if [ "$BUZZHEAVIER_SUCCESS" = "true" ]; then
            MIRRORS+="[BuzzHeavier]($BUZZHEAVIER_LINK)${NL}"
          fi
          if [ "$FILEBIN_SUCCESS" = "true" ]; then
            MIRRORS+="[Filebin]($FILEBIN_LINK)${NL}"
          fi

          if [ -n "$MIRRORS" ]; then
            MSG+="*Mirrors:*${NL}${MIRRORS}${NL}"
          fi

          if [ "$HAS_MODULES" = true ]; then
            MSG+="*Modules:*${MODULES}${NL}${NL}"
          fi

          MSG+="*APKs:*${APKS}"
          MSG=${MSG:0:9450}

          # Send to group
          curl -X POST \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "chat_id=${TG_CHAT}" \
            --data-urlencode "message_thread_id=${TG_THREAD_ID}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

          sleep 2

          # Send to channel
          curl -X POST \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "chat_id=${TG_CHANNEL}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

  build-stable:
    needs: [check-patch, build-dev]
    if: always() && needs.check-patch.outputs.trigger_stable == '1'
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (Main)
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          submodules: true

      - name: Setup Java (Zulu 17)
        uses: actions/setup-java@v5
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Notify Telegram (New Stable Patch)
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_THREAD_ID: "345"
          TAGS_OLD: ${{ needs.check-patch.outputs.tags_old }}
          TAGS_NEW: ${{ needs.check-patch.outputs.tags_new }}
        run: |
          set -euo pipefail
          NL=$'\n'
          MSG="*New Patch Detected!*${NL}"

          CHANGES=$(jq -n --argjson old "$TAGS_OLD" --argjson new "$TAGS_NEW" '
            [ $new | to_entries[] | . as $e
              | ($old[$e.key] // {}) as $o
              | select($e.value.stable != "" and $e.value.stable != ($o.stable // ""))
              | {
                  key: $e.key,
                  repo: $e.value.repo,
                  old: ($o.stable // ""),
                  new: $e.value.stable
                }
            ]
          ')

          if [ "$(echo "$CHANGES" | jq 'length')" -eq 0 ]; then
            MSG+="${NL}(Patch versions changed, but details could not be parsed)${NL}"
          else
            while read -r item; do
              name=$(echo "$item" | jq -r '.key')
              repo=$(echo "$item" | jq -r '.repo')
              old=$(echo "$item" | jq -r '.old')
              new=$(echo "$item" | jq -r '.new')
              MSG+="${NL}â€¢ [${name}](https://github.com/${repo}/releases/tag/${new}):${NL}Old: \`${old}\` â†’ New: \`${new}\`${NL}"
            done < <(echo "$CHANGES" | jq -c '.[]')
          fi

          MSG+="${NL}[Triggering new build...](https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)"
          MSG=${MSG:0:9450}

          curl -X POST \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "chat_id=${TG_CHAT}" \
            --data-urlencode "message_thread_id=${TG_THREAD_ID}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

      - name: Build Modules and APKs (Stable)
        run: |
          set -euo pipefail
          rm -rf build
          mkdir -p build
          ./build.sh .github/misc/config.stable.updated.toml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: $GITHUB_REPOSITORY
          NEXT_VER_CODE: ${{ needs.check-patch.outputs.next_stable_ver }}

      - name: Get Output (Stable)
        id: get_output_stable
        run: |
          set -euo pipefail
          DELIM="$(openssl rand -hex 8)"
          echo "BUILD_LOG<<${DELIM}" >> "$GITHUB_OUTPUT"
          cat build.md >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"
          cp -f build.md build.tmp

      - name: Upload to Release (Stable)
        uses: svenstaro/upload-release-action@v2
        with:
          body: ${{ steps.get_output_stable.outputs.BUILD_LOG }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ./build/*
          file_glob: true
          release_name: Build No. ${{ needs.check-patch.outputs.next_stable_ver }}
          tag: ${{ needs.check-patch.outputs.next_stable_ver }}
          overwrite: true

      - name: Upload to BuzzHeavier (Stable)
        id: upload_buzzheavier_stable
        env:
          BUZZHEAVIER_ACCOUNT_ID: ${{ secrets.BUZZHEAVIER_ACCOUNT_ID }}
          RELEASE_NUMBER: ${{ needs.check-patch.outputs.next_stable_ver }}
        run: |
          set -euo pipefail
          cd build || { echo "build folder not found"; exit 1; }

          # Create full archive ONCE
          ARCHIVE_NAME="archive-$RELEASE_NUMBER.zip"
          echo "ðŸ“¦ Creating full archive: $ARCHIVE_NAME"
          zip -q9 "$ARCHIVE_NAME" *

          TOKEN=$(echo "$BUZZHEAVIER_ACCOUNT_ID" | xargs)
          if [ -z "$TOKEN" ]; then
            echo "âŒ BUZZHEAVIER_ACCOUNT_ID secret is missing"
            exit 1
          fi
          AUTH="Authorization: Bearer $TOKEN"
          PARENT_ID="qapeaw1yzy6m"

          echo "âœ… Using revanced-builder directory ID: $PARENT_ID"
          echo "ðŸ” Checking if folder '$RELEASE_NUMBER' already exists..."

          # Fetch parent contents (NO TRAILING SPACES!)
          PARENT_CONTENTS=$(curl -sS -H "$AUTH" "https://buzzheavier.com/api/fs/$PARENT_ID")
          EXISTING_ID=$(echo "$PARENT_CONTENTS" | jq -r ".data.children[] // [] | select(.name == \"$RELEASE_NUMBER\" and .isDirectory == true) | .id // empty")

          if [ -n "$EXISTING_ID" ]; then
            echo "ðŸ—‘ï¸ Deleting existing folder '$RELEASE_NUMBER' (ID: $EXISTING_ID)..."
            curl -sS -X DELETE -H "$AUTH" "https://buzzheavier.com/api/fs/$EXISTING_ID" || true
            sleep 1
          fi

          echo "ðŸ“ Creating fresh folder: $RELEASE_NUMBER"
          CREATE_RES=$(curl -sS -X POST \
            -H "$AUTH" \
            -H "Content-Type: application/json" \
            -d "{\"name\":\"$RELEASE_NUMBER\"}" \
            "https://buzzheavier.com/api/fs/$PARENT_ID")

          RELEASE_DIR_ID=$(echo "$CREATE_RES" | jq -r '.data.id // empty')
          if [ -z "$RELEASE_DIR_ID" ]; then
            echo "âŒ Failed to create folder. Response: $CREATE_RES"
            exit 1
          fi
          echo "âœ… Folder created with ID: $RELEASE_DIR_ID"

          # Upload ALL files (including archive-XXX.zip)
          SUCCESS_COUNT=0
          for FILE in *; do
            if [ -f "$FILE" ]; then
              echo "â¬†ï¸ Uploading $FILE..."
              if curl -# -T "$FILE" -H "$AUTH" "https://w.buzzheavier.com/$RELEASE_DIR_ID/$FILE"; then
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                echo "âš ï¸ Failed to upload $FILE"
              fi
            fi
          done

          if [ "$SUCCESS_COUNT" -gt 0 ]; then
            PUBLIC_LINK="https://buzzheavier.com/$RELEASE_DIR_ID"
            echo "BUZZHEAVIER_LINK=$PUBLIC_LINK" >> "$GITHUB_OUTPUT"
            echo "UPLOAD_SUCCESS=true" >> "$GITHUB_OUTPUT"
            echo "âœ… Uploaded $SUCCESS_COUNT files. Mirror: $PUBLIC_LINK"
          else
            echo "UPLOAD_SUCCESS=false" >> "$GITHUB_OUTPUT"
            echo "BUZZHEAVIER_LINK=" >> "$GITHUB_OUTPUT"
            echo "âŒ No files uploaded to BuzzHeavier."
          fi

          echo "ðŸ§¹ Scanning for stale empty folders..."
          CLEANUP_CONTENTS=$(curl -sS -H "$AUTH" "https://buzzheavier.com/api/fs/$PARENT_ID")
          
          CANDIDATE_IDS=$(echo "$CLEANUP_CONTENTS" | jq -r ".data.children[] // [] | select(.isDirectory == true and .id != \"$RELEASE_DIR_ID\") | .id")

          for CID in $CANDIDATE_IDS; do
            CHILD_INFO=$(curl -sS -H "$AUTH" "https://buzzheavier.com/api/fs/$CID")
            
            ITEM_COUNT=$(echo "$CHILD_INFO" | jq '.data.children // [] | length')

            if [ "$ITEM_COUNT" -eq "0" ]; then
               echo "ðŸ—‘ï¸ Folder ID $CID is EMPTY (stale). Deleting..."
               curl -sS -X DELETE -H "$AUTH" "https://buzzheavier.com/api/fs/$CID" || true
            fi
          done

      - name: Upload to Filebin (Stable)
        id: upload_filebin_stable
        run: |
          set -euo pipefail
          cd build || { echo "build folder not found"; exit 1; }

          RELEASE_NUMBER="${{ needs.check-patch.outputs.next_stable_ver }}"
          ARCHIVE_NAME="archive-$RELEASE_NUMBER.zip"

          # The archive was already created by BuzzHeavier step â€” no need to recreate!
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "âŒ Expected archive $ARCHIVE_NAME not found!"
            exit 1
          fi

          BIN_ID="revanced-builder-stable-${RELEASE_NUMBER}-${{ github.run_id }}-${{ github.run_attempt }}"
          FILEBIN_URL="https://filebin.net"

          echo "â¬†ï¸ Uploading $ARCHIVE_NAME to Filebin bin: $BIN_ID"
          if curl --connect-timeout 30 --max-time 300 --fail-with-body --upload-file "$ARCHIVE_NAME" "$FILEBIN_URL/$BIN_ID/$ARCHIVE_NAME"; then
            echo "âœ… $ARCHIVE_NAME uploaded to Filebin"
            # Lock bin
            if curl --connect-timeout 10 --max-time 30 --fail-with-body -X PUT "$FILEBIN_URL/$BIN_ID"; then
              echo "ðŸ”’ Bin locked successfully."
            else
              echo "âš ï¸ Failed to lock bin (not critical)."
            fi
            echo "UPLOAD_SUCCESS=true" >> "$GITHUB_OUTPUT"
            echo "FILEBIN_LINK=$FILEBIN_URL/$BIN_ID/$ARCHIVE_NAME" >> "$GITHUB_OUTPUT"
          else
            echo "âŒ Failed to upload $ARCHIVE_NAME to Filebin."
            echo "UPLOAD_SUCCESS=false" >> "$GITHUB_OUTPUT"
            echo "FILEBIN_LINK=" >> "$GITHUB_OUTPUT"
          fi

          # DELETE archive-$RELEASE_NUMBER.zip AFTER upload (so it doesn't appear in Telegram)
          if [ -f "$ARCHIVE_NAME" ]; then
            echo "ðŸ—‘ï¸ Removing $ARCHIVE_NAME from local build dir"
            rm -f "$ARCHIVE_NAME"
          fi

      - name: Update Mirror Links (Stable)
        id: update_mirrors_stable
        env:
          RELEASE_NUM: ${{ needs.check-patch.outputs.next_stable_ver }}
          BUZZ_LINK: ${{ steps.upload_buzzheavier_stable.outputs.BUZZHEAVIER_LINK }}
          FILEBIN_LINK: ${{ steps.upload_filebin_stable.outputs.FILEBIN_LINK }}
        run: |
          set -euo pipefail

          # Ensure directory and file exist
          MIRRORS_DIR=".github/pages"
          MIRRORS_FILE="$MIRRORS_DIR/mirrors.md"
          mkdir -p "$MIRRORS_DIR"

          if [ ! -f "$MIRRORS_FILE" ]; then
            echo "# ðŸ—ƒï¸ Mirrors" > "$MIRRORS_FILE"
            echo "Updated automatically. Only recent 100 builds retained." >> "$MIRRORS_FILE"
            echo "" >> "$MIRRORS_FILE"
          fi

          # Skip if no release number (shouldn't happen, but safe)
          if [ -z "$RELEASE_NUM" ]; then
            echo "âš ï¸ No release number â€” skipping mirror update"
            exit 0
          fi

          # Create entry
          ENTRY="## Build No. $RELEASE_NUM  \n"
          if [ -n "$BUZZ_LINK" ]; then
            ENTRY+="ðŸ”— [BuzzHeavier]($BUZZ_LINK)  \n"
          fi
          if [ -n "$FILEBIN_LINK" ]; then
            ENTRY+="ðŸ”— [Filebin]($FILEBIN_LINK)  \n"
          fi
          if [ -z "$BUZZ_LINK" ] && [ -z "$FILEBIN_LINK" ]; then
            ENTRY+="âš ï¸ No mirrors available. Check [GitHub Release](https://github.com/$GITHUB_REPOSITORY/releases/tag/$RELEASE_NUM).  \n"
          fi
          ENTRY+="\n"

          # Create new file with: header + new entry + old entries (limited to 99 to keep 100 total)
          {
            # Keep header (first 3 lines)
            head -n 3 "$MIRRORS_FILE"
            # Add new entry
            echo -e "$ENTRY"
            # Add old entries (skip first 3 lines), keep only 99 blocks
            tail -n +4 "$MIRRORS_FILE" | awk '/^## Build No\./ { 
              if (block_count >= 99) { exit }
              block_count++
            }
            block_count <= 99 { print }'
          } > "$MIRRORS_FILE.tmp" && mv "$MIRRORS_FILE.tmp" "$MIRRORS_FILE"

      - name: Commit Updated mirrors.md (Stable)
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          skip_checkout: true
          file_pattern: .github/pages/mirrors.md
          commit_message: "Update mirrors.md for Build No. ${{ needs.check-patch.outputs.next_stable_ver }}"

      - name: Update Changelog and Magisk Update JSON (Stable)
        run: |
          set -euo pipefail
          git checkout -f update || git switch --discard-changes --orphan update
          cp -f build.tmp build.md
          get_update_json() {
            echo "{
            \"version\": \"$1\",
            \"versionCode\": ${{ needs.check-patch.outputs.next_stable_ver }},
            \"zipUrl\": \"$2\",
            \"changelog\": \"https://raw.githubusercontent.com/$GITHUB_REPOSITORY/update/build.md\"
          }"
          }
          cd build || { echo "build folder not found"; exit 1; }
          for OUTPUT in *magisk*.zip; do
            [ "$OUTPUT" = "*magisk*.zip" ] && continue
            ZIP_S=$(unzip -p "$OUTPUT" module.prop)
            if ! UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson); then continue; fi
            UPDATE_JSON="${UPDATE_JSON##*/}"
            VER=$(echo "$ZIP_S" | grep version=)
            VER="${VER##*=}"
            DLURL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ needs.check-patch.outputs.next_stable_ver }}/${OUTPUT}"
            get_update_json "$VER" "$DLURL" >"../$UPDATE_JSON"
          done
          cd ..
          find . -name "*-update.json" | grep . || : >dummy-update.json

      - name: Commit Updated Build MD and Update JSON Files (Stable)
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: update
          skip_checkout: true
          file_pattern: build.md *-update.json
          commit_message: Bump version ${{ needs.check-patch.outputs.next_stable_ver }}

      - name: Notify Telegram (Stable Build Complete)
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_THREAD_ID: "262"
          FILEBIN_LINK: ${{ steps.upload_filebin_stable.outputs.FILEBIN_LINK }}
          FILEBIN_SUCCESS: ${{ steps.upload_filebin_stable.outputs.UPLOAD_SUCCESS }}
          BUZZHEAVIER_LINK: ${{ steps.upload_buzzheavier_stable.outputs.BUZZHEAVIER_LINK }}
          BUZZHEAVIER_SUCCESS: ${{ steps.upload_buzzheavier_stable.outputs.UPLOAD_SUCCESS }}
        run: |
          set -euo pipefail
          cd build || exit 1
          NL=$'\n'
          APKS=""
          MODULES=""
          HAS_MODULES=false
          for OUTPUT in *; do
            DL_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ needs.check-patch.outputs.next_stable_ver }}/${OUTPUT}"
            if [[ $OUTPUT = *.apk ]]; then
              APKS+="${NL}${NL}[${OUTPUT}](${DL_URL})"
            elif [[ $OUTPUT = *.zip ]]; then
              MODULES+="${NL}${NL}[${OUTPUT}](${DL_URL})"
              HAS_MODULES=true
            fi
          done
          MODULES=${MODULES#"$NL"}
          APKS=${APKS#"$NL"}
          BODY="$(sed 's/^\* \*\*/â†ª \*\*/g; s/^\* `/â†ª \*\*/g; s/`/\*/g; s/^\* /\â†ª/g; s/\*\*/\*/g; s/###//g; s/^- /â†ª /g; /^==/d;' ../build.md)"

          MSG="*Build No. ${{ needs.check-patch.outputs.next_stable_ver }}*${NL}${NL}${BODY}${NL}${NL}"

          MIRRORS=""
          if [ "$BUZZHEAVIER_SUCCESS" = "true" ]; then
            MIRRORS+="[BuzzHeavier]($BUZZHEAVIER_LINK)${NL}"
          fi
          if [ "$FILEBIN_SUCCESS" = "true" ]; then
            MIRRORS+="[Filebin]($FILEBIN_LINK)${NL}"
          fi

          if [ -n "$MIRRORS" ]; then
            MSG+="*Mirrors:*${NL}${MIRRORS}${NL}"
          fi

          if [ "$HAS_MODULES" = true ]; then
            MSG+="*Modules:*${MODULES}${NL}${NL}"
          fi

          MSG+="*APKs:*${APKS}"
          MSG=${MSG:0:9450}

          # Send to group
          curl -X POST \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "chat_id=${TG_CHAT}" \
            --data-urlencode "message_thread_id=${TG_THREAD_ID}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

          sleep 2

          # Send to channel
          curl -X POST \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "chat_id=${TG_CHANNEL}" \
            "https://api.telegram.org/bot${TG_TOKEN}/sendMessage"

  cleanup:
    needs: [check-patch, build-dev, build-stable]
    if: always() && (needs.check-patch.outputs.trigger_prerelease == '1' || needs.check-patch.outputs.trigger_stable == '1')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    steps:
      - name: Delete Older Releases and Workflows
        uses: ophub/delete-releases-workflows@main
        with:
          delete_releases: true
          delete_tags: true
          releases_keep_latest: 100
          delete_workflows: true
          workflows_keep_day: 7
          gh_token: ${{ secrets.GITHUB_TOKEN }}
