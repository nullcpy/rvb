name: Build on Patch Update (Stale)

on:
  schedule:
    - cron: "20 9 * * *"
  workflow_dispatch:

concurrency:
  group: patch-build
  cancel-in-progress: false

jobs:
  check-patch:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    outputs:
      trigger: ${{ steps.compare.outputs.TRIGGER }}
      tags_old: ${{ steps.compare.outputs.tags_old }}
      tags_new: ${{ steps.compare.outputs.tags_new }}
      build_config: ${{ steps.generate_config.outputs.build_config }}
      next_ver: ${{ steps.versions.outputs.next_ver }}
    steps:
      - name: Checkout (Main)
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          submodules: true

      - name: Create .github/misc directory
        run: mkdir -p .github/misc

      - name: Ensure patch_sources_stale.json exists
        id: ensure_patch_sources
        run: |
          set -euo pipefail
          PATCH_FILE=".github/misc/patch_sources_stale.json"

          if [ ! -f "$PATCH_FILE" ]; then
            cat > "$PATCH_FILE" << 'EOF'
          {
            "patch": { "repo": "", "stable": "" }
          }
          EOF
            echo "created=true" >> "$GITHUB_OUTPUT"
          else
            echo "created=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit dummy patch_sources_stale.json if created
        if: steps.ensure_patch_sources.outputs.created == 'true'
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          skip_checkout: true
          file_pattern: .github/misc/patch_sources_stale.json
          commit_message: "Create dummy patch_sources_stale.json"

      - name: Fetch Latest Tags (from patch_sources_stale.json)
        if: steps.ensure_patch_sources.outputs.created == 'false'
        id: fetch_tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PATCH_FILE=".github/misc/patch_sources_stale.json"

          BASE_JSON=$(cat "$PATCH_FILE")
          if echo "$BASE_JSON" | jq -e 'length == 0' >/dev/null; then
            DELIM="$(openssl rand -hex 8)"
            echo "latest<<${DELIM}" >> "$GITHUB_OUTPUT"
            echo "$BASE_JSON" >> "$GITHUB_OUTPUT"
            echo "${DELIM}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          get_latest_tag() {
            local repo=$1
            # Fetch releases, exclude prereleases (stable only)
            local resp status body
            resp=$(curl -sS -w '%{http_code}' \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$repo/releases" || true)

            status="${resp: -3}"
            body="${resp::-3}"

            if [ "$status" != "200" ]; then echo ""; return 0; fi

            printf '%s\n' "$body" | jq -r "
              map(select(.prerelease == false and .tag_name != null and .tag_name != \"\")) |
              sort_by(.published_at) |
              reverse |
              .[0].tag_name // \"\"
            "
          }

          NEW_JSON="$BASE_JSON"

          # Iterate sources and get stable tags only
          while read -r id repo; do
            stable=$(get_latest_tag "$repo")
            NEW_JSON=$(jq \
              --arg id "$id" \
              --arg stable "$stable" \
              '.[$id].stable = $stable' \
              <<<"$NEW_JSON")
          done < <(echo "$BASE_JSON" | jq -r 'to_entries[] | select(.value.repo != "") | "\(.key) \(.value.repo)"')

          DELIM="$(openssl rand -hex 8)"
          echo "latest<<${DELIM}" >> "$GITHUB_OUTPUT"
          echo "$NEW_JSON" >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"

      - name: Compare Latest vs Stored Tags
        if: steps.ensure_patch_sources.outputs.created == 'false'
        id: compare
        run: |
          set -euo pipefail

          PATCH_FILE=".github/misc/patch_sources_stale.json"
          OLD_JSON=$(cat "$PATCH_FILE")
          NEW_JSON='${{ steps.fetch_tags.outputs.latest }}'

          if [ -z "$NEW_JSON" ]; then NEW_JSON="{}"; fi

          # Compute trigger for stable changes only
          TRIGGER=$(jq -n --argjson old "$OLD_JSON" --argjson new "$NEW_JSON" '
            [ $new | to_entries[] | . as $e
              | ($old[$e.key] // {}) as $o
              | select($e.value.stable != "" and $e.value.stable != ($o.stable // ""))
            ] | if length > 0 then 1 else 0 end
          ')

          # Update file
          echo "$NEW_JSON" > "$PATCH_FILE"
          echo "TRIGGER=$TRIGGER" >> "$GITHUB_OUTPUT"

          DELIM1="$(openssl rand -hex 8)"
          echo "tags_old<<${DELIM1}" >> "$GITHUB_OUTPUT"
          echo "$OLD_JSON" >> "$GITHUB_OUTPUT"
          echo "${DELIM1}" >> "$GITHUB_OUTPUT"

          DELIM2="$(openssl rand -hex 8)"
          echo "tags_new<<${DELIM2}" >> "$GITHUB_OUTPUT"
          echo "$NEW_JSON" >> "$GITHUB_OUTPUT"
          echo "${DELIM2}" >> "$GITHUB_OUTPUT"

      - name: Commit Updated patch_sources_stale.json
        if: steps.ensure_patch_sources.outputs.created == 'false' && steps.compare.outputs.TRIGGER == '1'
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          skip_checkout: true
          file_pattern: .github/misc/patch_sources_stale.json
          commit_message: "Update patch_sources_stale.json with latest versions"

      - name: Generate Config (Stale)
        if: steps.ensure_patch_sources.outputs.created == 'false' && steps.compare.outputs.TRIGGER == '1'
        id: generate_config
        env:
          TAGS_OLD: ${{ steps.compare.outputs.tags_old }}
          TAGS_NEW: ${{ steps.compare.outputs.tags_new }}
        run: |
          set -euo pipefail

          BASE_CONFIG=".github/misc/config.stale.toml"
          OUT_CONFIG=".github/misc/config.stale.build.toml"
          ACTIVE_FILE=".github/misc/active.stale.txt"

          # Create output file
          cp "$BASE_CONFIG" "$OUT_CONFIG"

          # 1. Identify which repos actually changed (Active list)
          jq -rn --argjson new "$TAGS_NEW" --argjson old "$TAGS_OLD" '
            [ $new | to_entries[] | . as $e
                | ($old[$e.key] // {}) as $o
                | select($e.value.stable != "" and $e.value.stable != ($o.stable // ""))
                | $e.value.repo
            ] | .[]
          ' > "$ACTIVE_FILE" || true

          # 2. Inject global settings for Stale (Enable Magisk Update)
          {
             echo 'enable-magisk-update = true'
             cat "$OUT_CONFIG"
          } > tmp_header && mv tmp_header "$OUT_CONFIG"

          # 3. Filter TOML: Disable sources that are not in the Active list
          awk -v active_file="$ACTIVE_FILE" '
            BEGIN {
              while ((getline repo < active_file) > 0) {
                if (repo != "") active[repo] = 1
              }
              close(active_file)
              section = ""
              keep = 0
            }
            /^\[.*\]/ {
              flush_section()
              section = $0
              delete lines
              n = 0
              lines[n++] = $0
              keep = 0
              next
            }
            {
              lines[n++] = $0
              if ($0 ~ /patches-source *= *"[^"]+"/) {
                match($0, /patches-source *= *"([^"]+)"/, m)
                src = m[1]
                if (src in active) {
                  keep = 1
                }
              }
              next
            }
            END {
              flush_section()
            }
            function flush_section() {
              if (n == 0) return
              for (i = 0; i < n; i++) {
                line = lines[i]
                if (!keep) {
                  gsub(/enabled *= *true/, "enabled = false", line)
                }
                print line
              }
            }
          ' "$OUT_CONFIG" > tmp && mv tmp "$OUT_CONFIG"

          echo "build_config=${OUT_CONFIG}" >> "$GITHUB_OUTPUT"

      - name: Commit Updated Config (Stale)
        if: steps.ensure_patch_sources.outputs.created == 'false' && steps.compare.outputs.TRIGGER == '1'
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: main
          file_pattern: .github/misc/config.stale.build.toml
          commit_message: "Update config.stale.build.toml for new stale patches"

      - name: Generate Version Numbers
        if: steps.ensure_patch_sources.outputs.created == 'false' && steps.compare.outputs.TRIGGER == '1'
        id: versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG=$(gh release list --exclude-drafts -L 100 | awk -F '\t' '$3 ~ /^[0-9]+$/ { print $3 }' | sort -nr | head -n1)
          if [ -z "$TAG" ] || ! [[ "$TAG" =~ ^[0-9]+$ ]]; then TAG=0; fi

          # Simple increment for Stale
          NEXT_VER=$((TAG + 1))

          echo "next_ver=${NEXT_VER}" >> "$GITHUB_OUTPUT"

  build-stale:
    needs: check-patch
    if: needs.check-patch.outputs.trigger == '1'
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (Main)
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          submodules: true

      - name: Setup Java (Zulu 17)
        uses: actions/setup-java@v5
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Build Modules and APKs (Stale)
        run: |
          set -euo pipefail
          rm -rf build
          mkdir -p build
          ./build.sh ${{ needs.check-patch.outputs.build_config }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: $GITHUB_REPOSITORY
          NEXT_VER_CODE: ${{ needs.check-patch.outputs.next_ver }}

      - name: Get Output (Stale)
        id: get_output_stale
        run: |
          set -euo pipefail
          DELIM="$(openssl rand -hex 8)"
          echo "BUILD_LOG<<${DELIM}" >> "$GITHUB_OUTPUT"
          cat build.md >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"
          cp -f build.md build.tmp

      - name: Upload to Release (Stale)
        uses: svenstaro/upload-release-action@v2
        with:
          body: ${{ steps.get_output_stale.outputs.BUILD_LOG }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ./build/*
          file_glob: true
          release_name: Build No. ${{ needs.check-patch.outputs.next_ver }}
          tag: ${{ needs.check-patch.outputs.next_ver }}
          overwrite: true

      - name: Update Changelog and Magisk Update JSON (Stale)
        run: |
          set -euo pipefail
          git checkout -f update || git switch --discard-changes --orphan update
          cp -f build.tmp build.md
          get_update_json() {
            echo "{
            \"version\": \"$1\",
            \"versionCode\": ${{ needs.check-patch.outputs.next_ver }},
            \"zipUrl\": \"$2\",
            \"changelog\": \"https://raw.githubusercontent.com/$GITHUB_REPOSITORY/update/build.md\"
          }"
          }
          cd build || { echo "build folder not found"; exit 1; }
          for OUTPUT in *magisk*.zip; do
            [ "$OUTPUT" = "*magisk*.zip" ] && continue
            ZIP_S=$(unzip -p "$OUTPUT" module.prop)
            if ! UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson); then continue; fi
            UPDATE_JSON="${UPDATE_JSON##*/}"
            VER=$(echo "$ZIP_S" | grep version=)
            VER="${VER##*=}"
            DLURL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/releases/download/${{ needs.check-patch.outputs.next_ver }}/${OUTPUT}"
            get_update_json "$VER" "$DLURL" >"../$UPDATE_JSON"
          done
          cd ..
          find . -name "*-update.json" | grep . || : >dummy-update.json

      - name: Commit Updated Build MD and Update JSON Files (Stale)
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          branch: update
          skip_checkout: true
          file_pattern: build.md *-update.json
          commit_message: Bump version ${{ needs.check-patch.outputs.next_ver }}

  cleanup:
    needs: [check-patch, build-stale]
    if: always() && needs.check-patch.outputs.trigger == '1'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    steps:
      - name: Delete Older Releases and Workflows
        uses: ophub/delete-releases-workflows@main
        with:
          delete_releases: true
          delete_tags: true
          releases_keep_latest: 100
          delete_workflows: true
          workflows_keep_day: 3
          gh_token: ${{ secrets.GITHUB_TOKEN }}
